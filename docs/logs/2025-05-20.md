# 📆 2025-05-20 学习计划

### 🎥 视频课程（目标：4个）

- [x] 1.基于flask框架实现Mock Server‌‌<br/>
（1）unittest中的mock模块‌‌<br/>
（2）postman中的Mock Server
- [x] 2.接口测试加密算法‌‌<br/>
对称加密、非对称加密（RSA、ECC、DH[Diffie-Hellman]）、哈希算法 ‌‌<br/>
（1）数字签名：通常使用非对称加密技术，比如RSA或ECC。数字签名的核心目的是确保数据的完整性和身份验证以及不可‌‌<br/>
否认‌‌性。签名的生成：使用私钥加密哈希值，接收方用公钥解密并验证哈希是否匹配.数字签名不加密数据本身，而是加密哈‌‌<br/>
希值，确保来源和完整性。不同的签名算法有各种的应用场景及优缺点。‌‌<br/>
    **一、数字签名的核心原理**
    数字签名是一种基于非对称加密的技术，用于验证数据的完整性、来源真实性和不可否认性。其核心流程如下：
    1. **签名生成**：  
       - 发送方使用**私钥**对数据的哈希值进行加密，生成签名。  
       - 公式：  
         签名 = 私钥加密（哈希（数据））
    2. **签名验证**：  
       - 接收方使用发送方的公钥解密签名，得到哈希值。  
       - 重新计算数据的哈希值，比对两者是否一致。 ‌‌<br/>
        
    **二、数字签名的核心特性**
    1. 完整性：任何数据篡改都会导致哈希值变化，验证失败。  
    2. 身份认证：只有私钥持有者能生成有效签名。  
    3. 不可否认性：签名者无法否认已签名的数据（除非私钥泄露）。 
    
    **三、常见数字签名算法**
     1. RSA-based签名:RSA-PKCS1-v1_5、RSA-PSS（Probabilistic Signature Scheme  
     2. ECDSA（Elliptic Curve Digital Signature Algorithm）
     3. EdDSA（Edwards-curve DSA）
     4. 后量子签名算法（应对量子计算威胁）：SPHINCS+、Dilithium 
     
    **四、数字签名的应用场景**
     1. HTTPS/TLS：服务器用私钥对证书签名，浏览器用公钥验证，确保网站身份。  
     2. 区块链与加密货币：比特币交易签名（ECDSA）、智能合约执行验证。
     3. 软件分发：开发者用私钥签名代码，用户验证防止篡改（如Windows驱动签名）。
     4. 电子邮件（PGP/GPG）：用私钥签名邮件，证明发件人身份。
     5. 法律与合同：电子合同签名（需符合法律标准如eIDAS）。
     
    **五、数字签名的安全性挑战**
     1. 私钥泄露：‌‌<br/>
     风险：攻击者伪造签名。‌‌<br/>
     防御：使用硬件安全模块（HSM）保护私钥。多因素认证（如阈值签名）。  
     2. 哈希碰撞：‌‌<br/>
     风险：构造不同数据生成相同哈希值。‌‌<br/>
     防御：采用抗碰撞哈希算法（如SHA-256、SHA-3）
     3. 算法漏洞：‌‌<br/>
     案例：索尼PS3因ECDSA随机数重复导致私钥泄露；早期RSA-PKCS1-v1_5填充漏洞。‌‌<br/>
     防御：使用标准算法（如EdDSA、RSA-PSS）
     4. 量子计算威胁：‌‌<br/>
     风险：Shor算法可破解RSA、ECC‌‌<br/>
     防御：迁移至后量子签名算法（如SPHINCS+）

    
---


### 💻 面试题刷题（牛客网）
* 堆和栈的区别？‌‌<br/>
堆和栈是程序运行时的两种重要内存区域，他们在内存分配、管理和使用方式上有显著差异。‌‌<br/>
    1、 **分配与释放方式**  
       - **栈**：由编译器自动管理，分配和释放遵循后进先出（LIFO）原则。例如，函数调用时局部变量入栈，函数返回时自动释放。  
       - **堆**：需手动申请和释放（如C/C++中的`malloc/new`和`free/delete`），程序员需自行管理内存，否则可能导致泄漏。‌‌<br/>
       
    2、 **内存布局与效率**  
       - **栈**：内存连续，仅通过移动栈指针分配，速度快且无碎片。  
       - **堆**：内存动态分配，可能产生碎片，分配需搜索合适内存块，速度较慢。‌‌<br/>
    
    3、 **容量限制**  
       - **栈**：通常较小（默认MB级），递归过深或大对象易导致栈溢出（Stack Overflow）。  
       - **堆**：受系统可用内存限制，可分配更大空间（需注意内存耗尽问题）。‌‌<br/>
    
    4、 **作用域与生命周期**  
       - **栈**：变量生命周期与函数绑定，函数结束即失效。  
       - **堆**：内存全局有效，需显式释放，可跨函数传递（如返回指针）。‌‌<br/>
    
    5、 **线程安全性**  
       - **栈**：每个线程独立，私有内存，无需同步。  
       - **堆**：进程内共享，多线程操作需同步机制（如锁）。‌‌<br/>
    
    6、 **错误处理**  
       - **栈溢出**：通常导致程序崩溃（如无限递归）。  
       - **堆分配失败**：返回空指针（如`malloc`返回`NULL`），需代码处理。‌‌<br/>

堆和栈的主要区别有：1、栈由系统自动分配，而堆是人为申请开辟；2、栈获得的空间较小，而堆获得的空间较大；3、栈由系统‌‌<br/>
自动分配，速度较快，而堆一般速度比较慢；4、栈是连续的空间，而堆是不连续的空间。


* 什么场景会内存泄漏？‌‌<br/>
内存泄漏的定义：指的是程序在动态分配堆内存后，失去了对该内存的控制，导致无法被释放，进而造成系统内存的浪费。‌‌<br/>
长期运行的程序如果存在内存泄漏，可能会导致内存耗尽，程序崩溃或系统变慢。（程序在运行过程中动态申请了堆内存，‌‌<br/>
但未正确释放，导致该内存无法再被使用或回收。）‌‌<br/>
1、显示分配后忘记释放‌‌<br/>
2、异常或错误路径未释放内存‌‌<br/>
3、循环引用（垃圾回收语言中的问题）‌‌<br/>
4、静态集合长期持有对象引用‌‌<br/>
5、未注销监听器或回调（注册了时间监听器、回调函数或定时器，但在对象销毁时未注销）‌‌<br/>
6、非托管资源未释放（操作文件、数据库连接、网络套接字等资源时，未显式关闭）‌‌<br/>
7、第三方库或系统资源未正确释放（调用第三方库的初始化函数后，未调用对应的清理函数）‌‌<br/>
如何避免内存泄漏：‌‌<br/>
1、手动管理语言（C/C++）：‌‌<br/>
（1）使用RAII（资源获取即初始化）模式‌‌<br/>
（2）优先使用智能指针‌‌<br/>
（3）确保每个malloc/new都有对应的free/delete‌‌<br/>
2、垃圾回收语言（Python/Java/JS）：‌‌<br/>
（1）避免不必要的全局引用。‌‌<br/>
（2）使用弱引用（weakReference）处理循环引用‌‌<br/>
（3）及时清理集合中的无用对象
3、通用方法：‌‌<br/>
（1）使用工具检测泄漏（如 Valgrind、AddressSanitizer、Java VisualVM、Chrome DevTools 内存快照）‌‌<br/>
（2）编写单元测试，覆盖资源分配/释放路径‌‌<br/>
（3）采用代码规范（如“谁分配，谁释放”）‌‌<br/>
总结：内存泄漏的根源在于未能正确管理资源的生命周期。理解代码中内存或资源的流动路径，结合工具检测和良好编程习‌‌<br/>
惯，可有效避免泄漏问题

* 请你说一说简单用户界面登录过程都需要做哪些分析？‌‌<br/>
     **一、功能测试**  
    **1. 正常登录验证**  
    - 输入正确的用户名和密码，提交后验证：  
      - ✅ 跳转到指定页面（如首页或用户中心）。  
      - ✅ 检查登录状态（如 Session 或 Token 是否生成）。  
    
    **2. 异常登录验证**  
    - **错误用户名/密码**：输入错误信息后：  
      - ✅ 提示明确错误（如“用户名或密码错误”），**不泄露用户是否存在**（避免安全风险）。  
      - ✅ 密码输入框内容自动清空，但用户名可保留（需符合安全要求）。  
    - **空输入**：不输入直接提交，验证是否提示必填字段（如“用户名不能为空”）。  
    
    **3. 输入边界值处理**  
    - **长度限制**：  
      - ✅ 用户名/密码过短（如小于6字符）或过长（如超过30字符），提交后提示格式错误。  
      - ✅ 数据库字段长度需与实际限制一致（避免后端截断导致漏洞）。  
    - **特殊字符**：输入含空格、中文、符号（如 `@#$%^&*`）的账号密码，验证：  
      - ✅ 前后空格自动过滤（如 `" user "` 转为 `"user"`）。  
      - ✅ 特殊字符支持存储和验证（需与注册规则一致）。  
    
    **4. 附加功能验证**  
    - **记住用户名**：  
      - ✅ 勾选后关闭页面重新打开，用户名自动填充，密码框为空。  
      - ✅ 不勾选时关闭页面后用户名不保存。  
    - **密码显示**：  
      - ✅ 输入密码时显示为星号或圆点（非明文）。  
      - ✅ 提供“显示密码”切换按钮（可选功能，需测试切换是否正常）。  
    - **验证码**（若有）：  
      - ✅ 验证码输入错误时提示并刷新新验证码。  
      - ✅ 验证码图片清晰度适中，支持颜色辅助选项（如灰度模式）。  
      - ✅ 验证码刷新按钮功能正常。  
    
    **5. 页面跳转与链接**  
    - ✅ 登录后跳转页面是否正确（如避免重定向漏洞）。  
    - ✅ 检查“注册”“忘记密码”“切换账号”等链接是否指向正确页面。  
    
    ---
    
    ### **二、界面测试**  
    **1. 视觉与交互**  
    - ✅ 布局对齐（如输入框、按钮居中或按设计稿排列）。  
    - ✅ 文字无错别字，提示信息友好（如“密码强度不足”而非“密码错误”）。  
    - ✅ 风格一致性（字体、颜色、间距与 UI 设计规范一致）。  
    
    **2. 响应式设计**  
    - ✅ 不同分辨率下页面元素自适应（如手机竖屏/横屏、PC 宽屏）。  
    
    ---
    
    ### **三、性能测试**  
    **1. 单用户性能**  
    - ✅ 页面加载时间 ≤ 2秒（可配置阈值）。  
    - ✅ 登录跳转时间 ≤ 1秒（依赖后端接口性能）。  
    
    **2. 多用户并发**  
    - ✅ 使用 JMeter 或 LoadRunner 模拟 1000 用户并发登录：  
      - 检查响应时间是否符合 SLA（如 95% 请求 < 3秒）。  
      - 验证系统无崩溃或内存泄漏。  
    
    ---
    
    ### **四、安全性测试**  
    **1. 数据传输与存储**  
    - ✅ 密码传输使用 HTTPS + 加密（如 AES 或 RSA）。  
    - ✅ 密码存储为哈希值（如 bcrypt + Salt）。  
    
    **2. 漏洞防护**  
    - ✅ SQL 注入：输入 `' OR '1'='1` 等攻击字符串，验证是否拦截。  
    - ✅ XSS 攻击：输入 `<script>alert(1)</script>`，验证是否过滤或转义。  
    - ✅ Cookie 安全：检查登录后的 Cookie 标记为 `HttpOnly` + `Secure`。  
    
    **3. 登录策略**  
    - ✅ 错误次数限制（如 5次失败后锁定账号或需验证码）。  
    - ✅ 多设备登录控制（如允许/禁止同一账号多端登录）。  
    
    ---
    
    ### **五、可用性测试**  
    **1. 键盘操作**  
    - ✅ 支持 Tab 键切换输入框，Enter 键提交表单。  
    - ✅ 焦点高亮显示（如当前输入框边框变色）。  
    
    ---
    
    ### **六、兼容性测试**  
    **1. 浏览器与设备**  
    - **PC 浏览器**：Chrome、Firefox、Edge、Safari、IE11（如需兼容）。  
    - **移动端**：iOS Safari、Android Chrome、主流厂商浏览器（如华为、小米）。  
    - **版本覆盖**：主版本及其前一个版本（如 Chrome 最新版和 Chrome-1）。  
    
    **2. 操作系统**  
    - ✅ Windows、macOS、Linux（若有需求）。  
    - ✅ iOS、Android（不同系统版本）。  
    
    ---
    
    ### **七、本地化测试**  
    **1. 多语言支持**  
    - ✅ 切换语言后页面元素无截断、错位（如德语长单词）。  
    - ✅ 错误提示与按钮文字随语言切换更新。  
    
    ---
    
    ### **测试工具推荐**  
    1. **功能/界面**：Selenium、Cypress（自动化测试）。  
    2. **性能**：JMeter、Gatling。  
    3. **安全**：OWASP ZAP、Burp Suite。  
    4. **兼容性**：BrowserStack、Sauce Labs（云端多平台测试）。  
    
    ---
    
    ### **注意事项**  
    - **环境隔离**：测试环境需与生产环境配置一致（如数据库、缓存）。  
    - **数据清理**：每次测试后清理测试账号，避免脏数据影响结果。  
    - **日志监控**：检查后端日志是否有异常报错（如未捕获的 NullPointerException）。  ‌‌<br/>
    
通过覆盖以上测试场景，可全面保障登录功能的稳定性、安全性和用户体验。


* 1000个苹果分成5堆，有多少种分法？‌‌<br/>

* 最长重复子串

---

📝 今日总结：
> 今天的视频1：
  今天的视频2：
  今天的视频3：